<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Go Language</title>

    <meta charset='utf-8'>
    <script src='slides/slides.js'></script>
      <link href="slides/slides.css" rel="stylesheet" type="text/css"/>
      <link href="slides/rdarder.css" rel="stylesheet" type="text/css"/>

      <script src="prettify/prettify.js"></script>
      <link href="prettify/sons-of-obsidian.css" type="text/css" rel="stylesheet" />
  </head>
  
  <style>
    /* Your individual styles here, or just use inline styles if that’s
       what you want. */
    
    
  </style>

  <body style='display: none' onload="prettyPrint()">

    <section class='slides layout-faux-widescreen template-golang'>
      

      <article>
        <h1>
          <a target="_blank" href="https://github.com/rdarder/gocached">Gocached</a>
          <br>
          <br>
        </h1>
        <p>
          A <a target="_blank" href="https://github.com/memcached/memcached">Memcached</a> implementation in Go
          <br>
        </p>
        <div class='source'>
          Rafael Darder - Rodolfo Granata - Julian Gutierrez
        </div>
      </article>

      <article class="cols2 wider">

      <h3>What is Memcached?</h3>
      <ul class="build left">
          <li>Client server memory object cache</li>
          <li>Off process key/value map with extra features</li>
          <li>Server works over tcp streams</li>
          <li>Protocol is line and byte oriented (mixed)</li>
          <li>Roles are classic client/server</li>
      </ul>
      <ul class="build right">
          <li>Requests from different clients operate on the same map</li>
          <li>Keys are ASCII strings</li>
          <li>Values are raw bytes</li>
          <li>Some operations interpret the value as a number</li>
          <li>Values may have an expiration time</li>
          <li>There are operations for controlling concurrence/locking</li>
      </ul>

      </article>

      <article class="wider cols2">
          <h3>Memcached stock implementation </h3>
          <ul class="build left">
              <li>Written in C</li>
              <li>The core is around 9000 SLOC</li>
              <li>All decisions towards performance</li>
              <li>Not easy to refactor, coupled by design</li>
              <li>It's <strong>very</strong> fast</li>
          </ul>
          <div class="build right">
              <a class="ref" href="https://github.com/memcached/memcached/blob/master/memcached.c#L311">
                  memcached.c:311
              </a>
          <pre target="_blank" class="rafa prettyprint lang-c">
/*
 * Adds a connection to the freelist. 0 = success.
 */
bool conn_add_to_freelist(conn *c) {
    bool ret = true;
    pthread_mutex_lock(&conn_lock);
    if (freecurr < freetotal) {
        freeconns[freecurr++] = c;
        ret = false;
    } else {
        /* try to enlarge free connections array */
        size_t newsize = freetotal * 2;
        conn **new_freeconns = realloc(freeconns, sizeof(conn *) * newsize);
        if (new_freeconns) {
            freetotal = newsize;
            freeconns = new_freeconns;
            freeconns[freecurr++] = c;
            ret = false;
        }
    }
    pthread_mutex_unlock(&conn_lock);
    return ret;
}
            </pre>
          </div>
      </article>

 <article>
     <h3>Gocached Goals</h3>
     <ul class="build">
         <li>Compatible with memcached protocol</li>
         <li>Written in go</li>
         <li>The core should be <a href="https://github.com/warlockcc/gocached">readable</a> in one sitting</li>
         <li>Intended for practising software design with go</li>
         <li>No specific efforts for performance</li>
         <li>Will it be fast enough?</li>
     </ul>
 </article>

 <article class="cols2 taller wider">
     <h3>Design - Phase 1 - Server scaffolding</h3>
     <ul class="build">
         <li>The server accepts connections on a tcp port</li>
         <li>typical tcp listen/accept flow</li>
         <li>When a client connects, establishes a session with the server</li>
         <li>not limited to one operation per connection as http1.0</li>
         <li>handle each connection/session with a separate goroutine.</li>
         <a target="_blank" class="ref" href="https://github.com/rdarder/gocached/blob/master/gocached.go#L55">gocached.go:55</a>
         <pre class="prettyprint rafa lang-go">
// network setup
if addr, err := net.ResolveTCPAddr("tcp", "0.0.0.0:"+*port); err != nil {
  logger.Fatalf("Unable to resolv local port %s\n", *port)
} else if listener, err := net.ListenTCP("tcp", addr); err != nil {
  logger.Fatalln("Unable to listen on requested port")
} else {
  // server loop
  logger.Printf("Starting Gocached server")
  for {
    if conn, err := listener.AcceptTCP(); err != nil {
      logger.Println("An error ocurred accepting a new connection")
    } else {
      go clientHandler(conn, eventful_storage)
    }
  }
}</pre>
     </ul>

 </article>

      <article class="cols2 wider">
          <h3>Design - Phase 1 - Server scaffolding</h3>
          <ul class="left build">
              <li>Each api command has a different parameter signature/format
              </li>
              <li>Part of the command interface should be to parse itself</li>
              <li>Commands starts with the command line as the first word,
                  followed by its parameters
              </li>
              <li>Tokenize the first line, identify command and delegate
                  parsing
              </li>
          </ul>
          <div class="right build">
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/command.go#L19">command.go:19</a>
<pre class="prettyprint rafa lang-go">
type Command interface {
  parse(line []string) bool
  Exec()
}
</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/command.go#L19">command.go:97</a>
<pre class="prettyprint rafa lang-go">
func (s *Session) CommandLoop() {

  for line := getTokenizedLine(s.bufreader);
      line != nil; line = getTokenizedLine(s.bufreader) {
    var cmd Command = cmdSelect(line[0], s)
    if cmd.parse(line) {
      cmd.Exec()
    }
  }
}
</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/command.go#L24">command.go:24</a>
<pre class="prettyprint rafa lang-go">
type StorageCommand struct {
  session     *Session
  command     string
  key         string
  flags       uint32
  exptime     uint32
  bytes       uint32
  cas_unique  uint64
  noreply     bool
  data        []byte
}
</pre>
          </div>
      </article>

      <article class="cols2 wider taller">
      <h3>Design - Phase 2 - Storage API</h3>
      <ul class="left build">
          <li>Parsing and command building example: get/gets</li>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/command.go#L215">command.go:215</a>
<pre class="prettyprint rafa lang-go">
func (self *RetrievalCommand) parse(line []string) bool {
  if len(line) < 2 {
    return Error(self.session, ClientError, "Bad retrieval command: missing parameters")
  }
  self.command = line[0]
  self.keys = line[1:]
  return true
}
</pre>

      </ul>
      <ul class="right build">
          <li>Basic Storage implementation, just use a map[string]</li>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/mapcachestorage.go#L9">mapcachestorage.go:9</a>
<pre class="prettyprint rafa lang-go">
type MapCacheStorage struct {
	storageMap map[string]*StorageEntry
	rwLock     sync.RWMutex
}
type StorageEntry struct {
  exptime    uint32
  flags      uint32
  bytes      uint32
  cas_unique uint64
  content    []byte
}
</pre>

      </ul>
          <div style="clear: all">
          <ul class="build">
              <li>CacheStorage: core key-value storage</li>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/cachestorage.go#L22">cachestorage.go:22</a>
<pre class="prettyprint rafa lang-go">
type CacheStorage interface {

  // Store this data.
  Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (previous *StorageEntry, result *StorageEntry)

  // Store this data, but only if the server *doesn't* already hold data for this key
  Add(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (err ErrorCode, result *StorageEntry)</pre>
          </ul>
              </div>

      </article>

      <article>
          <h3>Design - Phase 3 - Sync and Partitioning</h3>
          <ul class="build">
              <li>As there'll be many goroutines accessing this map directly, we need to sync, old school.</li>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/mapcachestorage.go#L32">mapcachestorage.go:32</a>
<pre class="prettyprint rafa lang-go">
func (self *MapCacheStorage) Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (previous *StorageEntry, result *StorageEntry) {
	self.rwLock.Lock()
	defer self.rwLock.Unlock()
	entry, present := self.storageMap[key]
	var newEntry *StorageEntry
	if present && !entry.expired() {
		newEntry = &StorageEntry{exptime, flags, bytes, entry.cas_unique + 1, content}
		self.storageMap[key] = newEntry
		return entry, newEntry
	}
	newEntry = &StorageEntry{exptime, flags, bytes, 0, content}
	self.storageMap[key] = newEntry
	return nil, newEntry
}</pre>
              <li>If many clients are connected, the map sync would be a bottleneck</li>
          </ul>

      </article>
      <article class="cols2 wider">
      <h3>Design - Phase 3 - Sync and Partitioning</h3>
      <ul class="left build">
          <li>Maps can be easily partitioned, by its keys (a.k.a. sharding)</li>
          <li>HashingStorage composes a set (array) of map storages.</li>
      </ul>
      <ul class="right build">
          <li>It's inmutable, so it doesn't need to be synchronized</li>
          <li>Just chooses the appropiate bucket and delegates to that CacheStorage</li>
      </ul>
          <ul class="build">
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/hashingstorage.go#L59">hashingstorage.go:59</a>
<pre class="prettyprint rafa lang-go">
func (self *HashingStorage) findBucket(key string) CacheStorage {
	storageIndex := self.hasher(key) % self.size
	storage := self.storageBuckets[storageIndex]
	return storage
}</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/hashingstorage.go#L19">hashingstorage.go:19</a>
<pre class="prettyprint rafa lang-go">
func (self *HashingStorage) Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (previous *StorageEntry, result *StorageEntry) {
	return self.findBucket(key).Set(key, flags, exptime, bytes, content)
}

func (self *HashingStorage) Add(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (err ErrorCode, result *StorageEntry) {
	return self.findBucket(key).Add(key, flags, exptime, bytes, content)
}</pre>

          </ul>

      </article>
      <article>
          <h3>Design - Phase 4 - Expiration</h3>
          <ul class="build">
              <li>Memcached supports expiration control</li>
              <li>Expiration is something that will happen in the future, but
                  won't get any notifications
              </li>
              <li>Brute force solution, periodically visit every key/value and
                  check if expired
              </li>
              <li>Lazy solution, expire entries only when new commands are to be
                  applied to the same key
              </li>
              <li>Decent solutions, keep track of entries that will expire</li>

              <ul>
                  <li>Fast lookup of entries to expire</li>
                  <li>Low maintenance of bookkeeping data structure</li>
              </ul>
          </ul>
      </article>
      <article class="cols2 wider">
          <h3>Expiration: Generational entries</h3>
          <ul class="left build">
              <ul>
                  <li>keep entries grouped by same expiry time slot</li>
                  <li>when a key is updated, possibly update the group</li>
                  <li>when a group time slot is over, expire it completely</li>
              </ul>
              <li>Bookkeeping is constant in time</li>
              <li>Generations can grow in time for non uniform expiring times</li>
          </ul>
          <ul class="right build">
      <a target="_blank" class="ref"
         href="https://github.com/rdarder/gocached/blob/master/generationalstorage.go#L50">generationalstorage.go:50</a>
<pre class="prettyprint rafa lang-go">
type GenerationalStorage struct {
  generations     map[int64] *Generation
  updatesChannel  chan UpdateMessage
  cacheStorage    CacheStorage
  lastCollected   int64
  items           uint64
}</pre>
      <a target="_blank" class="ref"
         href="https://github.com/rdarder/gocached/blob/master/generationalstorage.go#L33">generationalstorage.go:33</a>
<pre class="prettyprint rafa lang-go">
type Generation struct {
  startEpoch    int64
  inhabitants   map[string] bool
}
</pre>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/generationalstorage.go#L65">generationalstorage.go:65</a>
<pre class="prettyprint rafa lang-go">
func (self *GenerationalStorage) removeGenerationToCollect(now int64) *Generation {
  if now >= self.lastCollected + GenerationSize {
    gen := self.generations[now]
    self.generations[now] = nil, false
    self.lastCollected += GenerationSize
    return gen
  }
  return nil
}
</pre>
              </ul>

      </article>
      <article class="cols2 wider">
          <h3>Expiration: Time sorted bookkeeping</h3>
          <ul class="left build">
              <li>Use a heap to maintain entries in order. Add() is O(log(n)) in time</li>
              <li>Periodically get the tip of the heap entries, possibly expiring map entries</li>
              <li>An update would be costly, as we loose reference from the key to the heap position</li>
              <li>Allow spurious heap entries (i.e, when exptime is changed). Memory leak</li>

          </ul>
          <ul class="right build">
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/expiry/heap.go#L8">heap.go:8</a>
<pre class="prettyprint rafa lang-go">
type Entry struct {
	Key     *string
	Exptime uint32
}
type Heap []Entry
</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/heapexpiringstorage.go#L10">heapexpiringstorage.go:10</a>
<pre class="prettyprint rafa lang-go">
type HeapExpiringStorage struct {
  CacheStorage
  updatesChannel  chan UpdateMessage
	heap *expiry.Heap
}

func (hs *HeapExpiringStorage) ProcessUpdates() {
  for {
    msg := <-hs.updatesChannel
    switch msg.op {
    case Add, Change:
      hs.AddEntry(expiry.Entry{&msg.key, uint32(msg.newEpoch)}, uint32(msg.currentEpoch))
    case Collect:
      logger.Println("Collecting expired entries")
      hs.Collect(uint32(msg.currentEpoch))
    }
  }
}
</pre>

      </article>

    <article>
        <h3>Design - Phase 5 - Plumbing</h3>
        <ul class="build">
            <li>How do we implement different expiration/bookkeeping
                strategies?
            </li>
            <li>Solution1: make each bookkeeping strategy implement the storage
                interface
            </li><ul>
            <li>Can compose a mapstorage and delegate most storage logic</li>

        </ul>
            <li>What if we want to compose a HashingStorage?</li>
            <ul>
                <li>HashingStorage(bookkeeping(mapstorage)) vs
                    bookkeeping(HashingStorage(mapstorage))
                </li>
                <li>Wrapper soup</li>
            </ul>
        </ul>
    </article>
    <article>
        <h3>Design - Phase 5 - Plumbing</h3>
        <ul class="build">
                <li>Solution 2: Let's have event notifications from the storage</li>
                <li>just a decorator on a CacheStorage</li>
                <a target="_blank" class="ref"
                   href="https://github.com/rdarder/gocached/blob/master/eventnotifierstorage.go#L3">eventnotifierstorage.go:3</a>
<pre class="prettyprint rafa lang-go">
type EventNotifierStorage struct {
  updatesChannel chan UpdateMessage
  storage CacheStorage
}
</pre>
                <li>the notifying storage just propagates the event and delegates functionality</li>
                <li>bookkeeping structure can read the notifications</li>
                <li>bookkeeping will expire entries on the target storage when appropiate</li>
        </ul>
    </article>

    <article>
        <h3>Event notification</h3>
        <a target="_blank" class="ref"
           href="https://github.com/rdarder/gocached/blob/master/eventnotifierstorage.go#L33">eventnotifierstorage.go:33</a>
<pre class="prettyprint rafa lang-go">
func (self *EventNotifierStorage) Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (*StorageEntry, *StorageEntry) {
  previous, updated := self.storage.Set(key, flags, exptime, bytes, content)
  if (previous != nil) {
    self.updatesChannel <- UpdateMessage{Change, key, int64(previous.exptime), int64(exptime)}
  } else {
    self.updatesChannel <- UpdateMessage{Add, key, 0, int64(exptime)}
  }
  return previous, updated
}</pre>

    </article>

        <article>
          <h3>Building The Storage</h3>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/gocached.go#L33">gocached.go:33</a>
<pre class="prettyprint rafa lang-go">
if *partitions > 1 {
    partition_storage = newHashingStorage(uint32(*partitions), base_storage_factory)
} else {
    partition_storage = base_storage_factory()
}

// eventful storage implementation selection
switch *storage_choice {
case "leak":
    logger.Print("warning, will not expire entries")
    eventful_storage = partition_storage
case "generational":
    updatesChannel := make(chan UpdateMessage, 5000)
    eventful_storage = newEventNotifierStorage(partition_storage, updatesChannel)
    newGenerationalStorage(*expiring_frequency, partition_storage, updatesChannel)
case "heap":
    updatesChannel := make(chan UpdateMessage, 5000)
    eventful_storage = newEventNotifierStorage(partition_storage, updatesChannel)
    NewHeapExpiringStorage(*expiring_frequency, partition_storage, updatesChannel)
}</pre>
      </article>

    <article>
        <h3>Conclusions</h3>
        <ul class="build">
            <li>Less than 1k SLOC</li>
            <li>Mostly memcached compliant</li>
            <li>Informal benchmarks: gocached runs 30% slower than memcached</li>
            <li>Easy to read and modify</li>
        </ul>
    </article>
    </section>

  </body>
</html>
