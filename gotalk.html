<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Go Language</title>

    <meta charset='utf-8'>
    <script src='slides/slides.js'></script>
      <link href="slides/slides.css" rel="stylesheet" type="text/css"/>
      <link href="slides/rdarder.css" rel="stylesheet" type="text/css"/>

      <script src="prettify/prettify.js"></script>
      <link href="prettify/sons-of-obsidian.css" type="text/css" rel="stylesheet" />
      <link href="slides/rodo.css" rel="stylesheet" type="text/css"/>
  </head>
  
  <style>
    /* Your individual styles here, or just use inline styles if that’s
       what you want. */
    
    
  </style>

  <body style='display: none' onload="prettyPrint()">

    <section class='slides layout-faux-widescreen template-golang'>
      
      <article class='biglogo'>
      </article>

      <article>
        <h1>
          A tour of Go 
          <br>
          <br>
        </h1>
        <p>
          A birds of a feather talk
          <br>
        </p>
        <div class='source'>
          Rafael Darder - Rodolfo Granata - Julian Gutierrez (2012)
        </div>
      </article>

      
      <article class="rodo">
        <h3>Why ?</h3>
        <p>
          <ul>
            <li><h4>System languages not up to date with needs</h4></li>
            <ul>
              <li>network dominance, client/server focus.</li>
              <li>massive clusters, rise of multi-core CPUs.</li>
              <li>tangled libraries and dependency chains.</li>
            </ul>

            <li><h4>Construction speed</h4></li>
            <ul>
              <li>takes too long to build software.</li>
              <li>dependencies are uncontrolled.</li>
              <li>tools are slow and getting slower.</li>
              <li>machines aren't getting any faster.</li>
              <li>software keeps on growing.</li>
            </ul>

            <li><h4>Type system tyranny (you can't be safe + productive)</h4></li>
            <ul>
              <li>people are driven away to dynamically typed languages.</li>
              <li>programming gets harder because of bad implementations.</li>
              <li>types in large programs don't easily fall in a hierarchy, we spend too much time rearranging inheritance.</li>
            </ul>
          </ul>
        </p>
      </article>

      
      <article class="rodo">
        <h3>Goals</h3>
        <p>
          <ul>
            <li><h4>Efficiency and safety of statically typed languages</h4></li>
            <ul>
              <li><b>type safe: </b>you can't missinterpret
              types <span style="color:white;">(eg: 1 + bool).<span></li>
              <li><b>memory safe: </b> you can't corrupt memory
              <span style="color:white;">(eg: no unions).</span></li>
            </ul>

            <li><h4>Flexibility and ease of dynamically typed languages</h4></li>
            
            <li><h4>Good support for concurrency and communication</h4></li>
            <ul>
              <li>goroutines</li>
              <li>channels</li>
            </ul>

            <li><h4>Efficient latency-free garbage collector</h4></li>
            <ul>
              <li>Easier to write concurrent programs.</li>
              <li>Solve the problem once instead of in every program.</li>
              <li>Go gives the programmer control over memory layout and allocation.</li>
            </ul>

            <li><h4>High speed compilation</h4></li>            
            <ul>
              <li>Pull transitive dependencies from object files
              instead of recompiling.</li>
            </ul>
          </ul>
        </p>
      </article>

      
      <article class="rodo">
        <h3>Design Principles</h3>
        <p>
          <ul>
            <li><h4>Keep concepts orthogonal</h4></li>
            <ul>
              <li>methods can be implemented for any type.</li>
              <li>use structures to representa data.</li>
              <li>use interfaces to represent behaviour
              <span style="color:white;">(eg: C++ ABCs / Java interfaces).</span</li>
            </ul>

            <li><h4>Simple and regular grammar</h4></li>
            <ul>
              <li>read declarations forward.</li>
              <li>easier and faster to parse.</li>
            </ul>
            
            <li><h4>Reduce typing, let the language figure it out</h4></li>
            <ul>
              <li>no semmicolons.</li>
              <li>no parenthesized expressions on control blocks.</li>
            </ul>

            <li><h4>Keep type system clear</h4></li>
            <ul>
              <li>don't loose time fitting types into a hierarchy, there's no inheritance.</li>
              <li>no need to announce type relationships.</li>
              <li><a href="http://golang.org/doc/go_faq.html#types">Type FAQs.</a></li>
            </ul>
          </ul>
        </p>
      </article>


      <article class="rodo twopanels">
        <h3>Primitive Types</h3>
        <div class="leftside"><pre class="prettyprint"><code>
// boolean
var state  bool    = false

// strings
var color  string  = "Green"

// numeric types
var secs   int     = 1045
var age    uint8   = 23
var bignum int64   = 1<<62

var height float32 = 32.4
var heigh2 float64 = 64.4

var cangle complex64 = complex(1.0, -0.33)

// arrays
var temperatures = [...]float32 {19.1, 23.4, 30.3, 39.2}
var pixels [640][480]int32

// slices: a view over arrays
var lowtemps = temperatures[:2]
var midtemps = temperatures[1:2]
var higtemps = temperatures[2:]

// map types
var timezone_shift = map[string]int {
  "UTC":  0 * 3600,
  "ARG": -3 * 3600,
  "EST": -5 * 3600,
  "PST": -8 * 3600,
}
        </code></pre></div>
        <div class="rightside sidelist">
          <ul>
            <li>Strings and Maps are part of the language.</li>
            <li>Slices under the covers</li>
            <ul>
              <li>a pointer to an array</li> 
              <li>a length</li>
              <li>capacity (how much can a slice grow)</li>              
            </ul>
            <li>Every value is initialized to it's "zero value"</li>
            <li><b>new:</b> allocates values on the heap and returns
            their address.</li>
            <li><b>make:</b> creates maps, slices, channels
            (initializes to non zero values)</li>
          </ul>
        </div>
      </article>


      <article class="rodo twopanels article-structs">
        <h3>Struct Types (and code reuse)</h3>
        <div class="leftside"><pre class="prettyprint"><code>
package main

import (
  "sync"
  "time"
)

// define a URL type
type URL string

// description of a URL mapping
type URLMapping struct {
  Origin      URL
  Destination URL
  Visits      uint64
  Creation    time.Time
}

// the shortener holds all mappings
// and a lock for concurrent access
type URLShortener struct {
  Mappings map[*URL]URLMapping
  Mutex    sync.RWMutex
}

// a shortener that keeps stats
type MetricShortener struct {
  URLShortener      // anonymous field
  TotalLookups      uint64
  AvgResolutionTime float32
}
        </code></pre></div>
        <div class="rightside sidelist">
        <pre class="prettyprint"><code>
func main() {
  var ms = MetricShortener{
    URLShortener: URLShortener{
      Mappings: make(map[*URL]URLMapping)},
    TotalLookups:      0,
    AvgResolutionTime: 0.0}

  var nm = URLMapping{
    Origin:      "http://short.org/test",
    Destination: "http://www.testurl.org/longurl",
    Visits:      0,
    Creation:    time.Now()}

  ms.Mutex.Lock()
  ms.Mappings[&nm.Origin] = nm
  ms.Mutex.Unlock()
}
        </code></pre>

          <ul>
            <li>The way to model data.</li>
            <li>A sequence of fields with a name and a type.</li>
            <li>Anonymous / embedded fields</li> 
            <ul>
              <li>type name acts like field name.</li> 
              <li>its fields and methods get lifted to the struct.</li>
            </ul>
          </ul>
        </div>
      </article>


      <article class="rodo twopanels article-functions">
        <h3>Functions</h3>
        <div class="leftside"><pre class="prettyprint"><code>
// A function returning multiple values
func DivMod(a, b int) (div, rem int) {
  return a / b, a % b
}

// A func with a variadic parameter
func Add(list ...int) (sum int) {
  for _, n := range list {
    sum += n
  }
  return
}

// A function returning a 'function returning int'
func NewCounter(base int) func() int {
  return func() int {
    base += 1
    return base
  }
}


func main() {
  // don't forget to salut
  defer fmt.Println("Good bye!")

  // function chaining using multiple arguments
  var div, rem = DivMod(DivMod(23, 4))
  fmt.Printf("div: %v, rem: %v\n", div, rem)

  // create a new counter and add some of its values
  counter := NewCounter(0)
  fmt.Printf("Total count: %v\n",
    Add(counter(), counter(), counter()))
}
        </code></pre></div>
        <div class="rightside sidelist">
          <ul>
            <li>Functions can return multiple values.</li>
            <ul>
              <li>arguments can be unpacked.</li>
            </ul>
            <li>Variadics allow a variable number of arguments in
            function calls.</li>
            <li>Funtions are 1st class values</li>
            <ul>
              <li>used as arguments and return values.</li>
              <li>support for closures (keep context).</li>
            </ul>
            <li><b>defer:</b> execution on function rolloff.</li>
            <ul>
              <li>Useful for freeing locks, closing files.</li>
            </ul>
          </ul>
        </div>
      </article>

      
      <article class="rodo twopanels article-methods">
        <h3>Methods</h3>
        <div class="leftside"><pre class="prettyprint"><code>
// just an IPv4 address type
type IPv4Addr [4]byte

// a method for an IPv4 address to convert to string
func (addr *IPv4Addr) String() (r string) {
  for _, octet := range addr {
    r += "." + strconv.Itoa(int(octet))
  }
  return r[1:] // remove first dot
}

// network address calculation
func (addr *IPv4Addr) Net(mask *IPv4Addr) IPv4Addr {
  return IPv4Addr{
    addr[0] & mask[0], addr[1] & mask[1],
    addr[2] & mask[2], addr[3] & mask[3]}
}


func main() {
  var addr = IPv4Addr{172, 27, 27, 23}
  var mask = IPv4Addr{255, 255, 255, 0}
  var net = addr.Net(&mask)

  fmt.Printf("Addr: %v\n", addr.String())
  fmt.Printf("Mask: %v\n", mask.String())
  fmt.Printf("Network: %v\n", net.String())
}

// Output
Addr: 172.27.27.23
Mask: 255.255.255.0
Network: 172.27.27.0
        </code></pre></div>
        <div class="rightside sidelist">
          <ul>
            <li>Methods can be defined for any type, not just
              structs.</li>
            <li>They look like a function but have a receiver before
            the name.</li>
            <li>The <b>method set</b> of a type are all functions with
            the type as a receiver.</li>
            <li>A receiver (the <b>this</b> pointer) can be also a
            value. The method get's a copy of the object.</li>
          </ul>
        </div>
      </article>

      
      <article class="rodo twopanels article-interfaces">
        <h3>Interface Types</h3>
        <div class="leftside"><pre class="prettyprint"><code>
// A movie Search interface
type MovieSource interface {
  Search(movie string) string
}

// REST movie service
type IMDBService struct {
  ServiceURL string
}

// DB movie storage
type MySQLBackend struct {
  Host, Port string
}

// Search method for MySQL backend
func (d *MySQLBackend) Search(movie string) string {
  var conn = d.Connect(d.Host, d.Port)
  log.Printf("Querying MySQL db for %v\n", movie)
}

// Search method for IMDB
func (d *IMDBService) Search(movie string) string {
  var conn = d.Connect(d.ServiceURL)
  log.Printf("Querying IMDB db for %v\n", movie)
}

// Lookup a movie
func Lookup(source MovieSource, name string) string {
  return source.Search(name)
}

func main() {
  imdb := NewIMDBService()
  mydb := NEWMysqlBackend()
  Lookup(imdb, "The Go movie!")
  Lookup(mydb, "The Go movie!")  
}        </code></pre></div>
        <div class="rightside sidelist">
          <ul>
            <li>The way to model behaviour.</li>
            <li>A type can fulfill multiple interfaces at once.</li>
            <li>Declaration and Implementation are totally
              decoupled</li>
            <ul>
              <li>if a type provides the methods, it implements the
                interface.</li>
              <li>Consequence: NO type hierarchy</li>
            </ul>
            <li>Interface values have a static type and a dynamic
              type.</li>
            <ul>
              <li><b>static</b>: the value being boxed.</li>
              <li><b>dynamic</b>: the interface type.</li>              
            </ul>
            <li>Dynamic dispatch depending on the type of the boxed
              value.</li>
            <ul><li>Go's polymorphism.</li></ul>
            <li>The empty interface can contain any type.</li>
          </ul>
        </div>
      </article>


      <article class="rodo article-looping">
        <h3>Looping</h3>
        <div class=""><pre class="prettyprint"><code>
package main

import (
  "fmt"
  "math/rand"
)

func main() {

  var temperatures = make([]float32, 10)

  // generate 10 random temperatures
  for i := 0; i < 10; i++ {
    temperatures = append(temperatures, 15.0 + 13.0 * rand.Float32())
  }

  // discard temperatures higher than 20.0
  for i, temp := range temperatures {
    if temp > 20.0 {
      temperatures = append(temperatures[:i], temperatures[i+1:]...)
    }
  }

  var timezones = map[string]int{"ARG": -3, "MST": -7}

  for zone, shift := range timezones {
    fmt.Printf("%v is %v hours away.\n", zone, shift)
  }

  for {
    //eternal loop
  }
}        </code></pre></div>
      </article>

      
      <article class="rodo twopanels article-branches">
        <h3>Branching</h3>
        <div class="leftside"><pre class="prettyprint"><code>
if v := getValue(); v < low {

  // value is smallest 

} else if v > high {

  // value is largest

} else {

  // value is in between

}
        </code></pre></div>

        <div class="leftside">
        <pre class="prettyprint"><code>
switch {
            
case x < min, x > max:
  // out of bounds

default:
  // x in range min : max
}
        </code></pre>
        </div>

        <div class="leftside">
        <pre class="prettyprint"><code>
switch i := x.(type) {
case nil:
  printString("x is nil")
case int:
  printInt(i)  // i is an int
case float64:
  printFloat64(i)  // i is a float64
case func(int) float64:
  printFunction(i)  // i is a function
case bool, string:
  printString("type is bool or string")  // i is an interface{}
default:
  printString("don't know the type")
}          
        </code></pre>
        </div>

      </article>





      <article>
        <h1>
          Concurrency 
          <br>
        </h1>
      </article>

      <article class='smaller'>
        <h3>
        Main concepts: Goroutines
        </h3>
        <ul>
          <li>
            A method executing concurrently in the same address space.
          </li>
          <li>
			Multiplexed onto OS threads (M:N model).
		  </li>
          <li>
            Natively supported by the language.
          </li>
          <li>
            Just prefix a function invocation with the go keyword. 
          </li>
        </ul>
        <pre class="prettyprint">
<code>
  go func() { fmt.Print("Hello Concurrent World!") } ()
</code>
        </pre>
        
      </article>

      <article class='smaller' style='
    padding-left: 10px;
    padding-right: 10px;
    padding-top: 10px;
    padding-bottom: 10px;'>
        <h3>
        An example - A simple Netcat-like tool
        </h3>
        <table style='margin-top: 10px;' class='build'>
          <tr>
            <td style="border: 0">
              <pre class="prettyprint" style='margin-top: 0px; margin-bottom: 0px;'>
<code>
func main() {
	if len(os.Args) != 2 {
		fmt.Printf("Usage: %s &lturl&gt:&ltport&gt\n", os.Args[0])
		os.Exit(-1)
	}
	url := os.Args[1]
	
	var urlAddress *net.TCPAddr
	var urlConn *net.TCPConn
	var err error

	if urlAddress, err = net.ResolveTCPAddr("tcp4", url); err != nil {
		fmt.Printf("Error resolving URL address: %s\n", url)
		os.Exit(-1)
	}

	if urlConn, err = net.DialTCP("tcp", nil, urlAddress); err != nil {
		fmt.Printf("Error connecting to URL: %s\n", urlAddress)
		os.Exit(-1)
	}
	go monkey(os.Stdin, urlConn, 1024)
	monkey(bufio.NewReader(urlConn), os.Stdout, 1024)
}
</code>
        </pre>
             </td>
            <td style="border: 0">
              <ul>
                <li>
                  A method executing concurrently in the same address space.
                </li>
                <li>
			      Multiplexed onto OS threads (M:N model).
		        </li>
                <li>
                  Natively supported by the language.
                </li>
                <li>
                  Just prefix a function invocation with the go keyword. 
                </li>
              </ul>
            </td>
          </tr>
        </table>       
      </article>

      <article class='smaller'>
        <h3>
        Main concepts: Goroutines
        </h3>
        <p>
        The writer function just moves chunks of data from reader into a writer
        </p>
        <pre class="prettyprint">
<code>
func monkey(r io.Reader, to io.Writer, bufSize int) {
  b := make([]byte, bufSize)
  for {
    n, err := r.Read(b)
    if err != nil {
      return
    }
    if n > 0 {
      to.Write(b[0:n])
    }
  }
}
</code>
        </pre>
        
      </article>

      <article class='smaller'>
        <h3>
        Communication
        </h3>
        <ul class="build">
          <li>
			Goroutines are not quite useful if they can't communicate with each other.
          </li>
          <li>
			But communicating by sharing memory has a lot of well-known drawbacks.
		    <ul class="build">
		    <li>
		    Lock based solutions don't compose.		  
		    </li>
		    <li>
		    Deadlock prone.
		    </li>
		    <li>
		    Hard to reason.
		    </li>
		    </ul>
		  </li>
          <li>
			"Do not communicate by sharing memory; instead, share memory by communicating."
          </li>
          <li>
            Go channels to the rescue! 
          </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>
        Channels
        </h3>
        <ul class="build">
          <li>
			Inspired on Tony Hoare's ideas of concurrency in CSP.
		    <ul class="build">
		    <li>
			Rendezvous model.
		    </li>
		    <li>
		    But support both syncronous/asynchronous message passing.
		    </li>
		    <li>
			They are not tied to a goroutine like in the actor model.		    
			</li>
		    </ul>
		  </li>
          <li>
			Two main use cases: 
			<ul class="build">
		    <li>
			Communication.
		    </li>
		    <li>
			Coordination.
			</li>
			</ul>
          </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>
        Channels
        </h3>
        <ul class="build">
          <li>
          	Channels are reference types, so they are created using make (instead of new) 
        <pre class="prettyprint" style="margin-top: 10px; margin-bottom: 10px;">
<code>
  myChannel := make(chan string)
  bufferedChannel := make(chan string, 1024)                
</code>
        </pre>
		  </li>
          <li>
			Some constraints can be added to restrict the usage of a channel 
          <pre class="prettyprint" style="margin-top: 10px; margin-bottom: 10px;">
<code>
  receiverChannel := make(chan<- string)
  senderChannel := make(<-chan string)
</code>
        </pre>
		  </li>
          <li>
    	    Two operators for send/receive   
          <pre class="prettyprint" style="margin-top: 10px; margin-bottom: 10px;">
<code>
  myChannel <- "This is a message" //Sends a message
  msg := <- myChannel // Receives the message
  msg, ok := <- myChannel // ok is true while the channel is open
</code>
        </pre>
        </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>
        Channels
        </h3>
        <ul class="build">
          <li>
    		Channels can be closed to indicate that there are no more messages.
        <pre class="prettyprint" >
<code>
    receiverChannel := make(chan<- string)
    close(receiverChannel)
</code>
        </pre>
		  </li>
          <li>
			A client can pull for messages until the channel is closed.
          <pre class="prettyprint" >
<code>
  for msg := range(senderChannel) {
      fmt.Print(msg)
  }
</code>
        </pre>
		  </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>
        Channels
        </h3>
		<p>
			Reading from multiple channels: Select
		</p>
		<ul class='build'>
		<li>
		    A "select" statement chooses which of a set of possible communications will proceed.
		</li>
		<li>
		    It looks similar to a "switch" statement but with the cases all referring to communication operations. 
		</li>
		</ul>
        <table style="margin-top: 0px;">
        <tr>
          <td style="border: 0px" class="build">
            <pre class="prettyprint" style="margin-top: 0px;">
<code>
select {
  case i1 := <-c1:
	print("received ", i1, " from c1\n")
  case c2 <- 1:
	print("sent 1 to c2\n")
case i3, ok := (<-c3):  // same as: i3, ok := <-c3
	if ok {
		print("received ", i3, " from c3\n")
	} else {
		print("c3 is closed\n")
	}
default:
	print("no communication\n")
}</code>
            </pre>
          </td>
          <td style="border: 0px">
            <ul class="build">
            <li>
            All the channel expressions are evaluated.
            </li>
            <li>
            One channel expression per case statement 
            </li>
            <li>
            Send and receive expressions are allowed.
            </li>
            <li>
            If all the channels expression will block, default wins.  
            </li>
            <li>
            Can be used for non-blocking reads.
            </li>
            </ul>
          </td>
        </tr>        
        </table>
      </article>

      <article class="smaller">
        <h3>
        Channels: Some idioms
        </h3>
        <ul class="build">
        <li>
        <p>
          Generators à la Python
        </p>
        <p>
          Basically, a generator is a function that returns a channel. The client can iterate over
          that channel.
        </p>
          <pre class="prettyprint" style="margin-top: 0px;">
<code>
func to(n int) (c chan int) {
  c = make(chan int)
  go func() {
    defer close(c)
    for i := 0; i &lt n; i++ {
      c &lt- i // yield a new value
    }
  }()
  return
}

func main() {
  for i := range(to(42)) {
    fmt.Print(i)
  }
}
</code>
        </li>
        </ul>
      </article>

      <article class='smaller'>
        <h3 class='build'>
	  Some thoughts on concurrency and parallelism
        </h3>
	  <ul class='build'>
	  <li>
		  Concurrency is not parallelism
	  </li>
	  <li>
	      Concurrency is about the composition of independently executing processes. Make happens-before relation a little less restrictive.
	  </li>
	  <li>
	      Parallelism is about doing lots of things at once. 
	  </li>
	  <li>
	      Concurrency is useful to design some kind of problems (e.g: our netcat example)
	    </li>
	  <li>
	      Concurrency enables parallelism.
	    </li>
	  </ul>
      </article>









      <article>
        <h1>
          <a target="_blank" href="https://github.com/rdarder/gocached">Gocached</a>
          <br>
          <br>
        </h1>
        <p>
          A <a target="_blank" href="https://github.com/memcached/memcached">Memcached</a> implementation in Go
          <br>
        </p>
        <div class='source'>
          Rafael Darder - Rodolfo Granata - Julian Gutierrez
        </div>
      </article>

      <article class="cols2 wider">

      <h3>What is Memcached?</h3>
      <ul class="build left">
          <li>Client server memory object cache</li>
          <li>Off process key/value map with extra features</li>
          <li>Server works over tcp streams</li>
          <li>Protocol is line and byte oriented (mixed)</li>
          <li>Roles are classic client/server</li>
      </ul>
      <ul class="build right">
          <li>Requests from different clients operate on the same map</li>
          <li>Keys are ASCII strings</li>
          <li>Values are raw bytes</li>
          <li>Some operations interpret the value as a number</li>
          <li>Values may have an expiration time</li>
          <li>There are operations for controlling concurrence/locking</li>
      </ul>

      </article>

      <article class="wider cols2">
          <h3>Memcached stock implementation </h3>
          <ul class="build left">
              <li>Written in C</li>
              <li>The core is around 9000 SLOC</li>
              <li>All decisions towards performance</li>
              <li>Not easy to refactor, coupled by design</li>
              <li>It's <strong>very</strong> fast</li>
          </ul>
          <div class="build right">
              <a class="ref" href="https://github.com/memcached/memcached/blob/master/memcached.c#L311">
                  memcached.c:311
              </a>
          <pre target="_blank" class="rafa prettyprint lang-c">
/*
 * Adds a connection to the freelist. 0 = success.
 */
bool conn_add_to_freelist(conn *c) {
    bool ret = true;
    pthread_mutex_lock(&conn_lock);
    if (freecurr < freetotal) {
        freeconns[freecurr++] = c;
        ret = false;
    } else {
        /* try to enlarge free connections array */
        size_t newsize = freetotal * 2;
        conn **new_freeconns = realloc(freeconns, sizeof(conn *) * newsize);
        if (new_freeconns) {
            freetotal = newsize;
            freeconns = new_freeconns;
            freeconns[freecurr++] = c;
            ret = false;
        }
    }
    pthread_mutex_unlock(&conn_lock);
    return ret;
}
            </pre>
          </div>
      </article>

 <article>
     <h3>Gocached Goals</h3>
     <ul class="build">
         <li>Compatible with memcached protocol</li>
         <li>Written in go</li>
         <li>The core should be <a href="https://github.com/warlockcc/gocached">readable</a> in one sitting</li>
         <li>Intended for practising software design with go</li>
         <li>No specific efforts for performance</li>
         <li>Will it be fast enough?</li>
     </ul>
 </article>

 <article class="cols2 taller wider">
     <h3>Design - Phase 1 - Server scaffolding</h3>
     <ul class="build">
         <li>The server accepts connections on a tcp port</li>
         <li>typical tcp listen/accept flow</li>
         <li>When a client connects, establishes a session with the server</li>
         <li>not limited to one operation per connection as http1.0</li>
         <li>handle each connection/session with a separate goroutine.</li>
         <a target="_blank" class="ref" href="https://github.com/rdarder/gocached/blob/master/gocached.go#L55">gocached.go:55</a>
         <pre class="prettyprint rafa lang-go">
// network setup
if addr, err := net.ResolveTCPAddr("tcp", "0.0.0.0:"+*port); err != nil {
  logger.Fatalf("Unable to resolv local port %s\n", *port)
} else if listener, err := net.ListenTCP("tcp", addr); err != nil {
  logger.Fatalln("Unable to listen on requested port")
} else {
  // server loop
  logger.Printf("Starting Gocached server")
  for {
    if conn, err := listener.AcceptTCP(); err != nil {
      logger.Println("An error ocurred accepting a new connection")
    } else {
      go clientHandler(conn, eventful_storage)
    }
  }
}</pre>
     </ul>

 </article>

      <article class="cols2 wider">
          <h3>Design - Phase 1 - Server scaffolding</h3>
          <ul class="left build">
              <li>Each api command has a different parameter signature/format
              </li>
              <li>Part of the command interface should be to parse itself</li>
              <li>Commands starts with the command line as the first word,
                  followed by its parameters
              </li>
              <li>Tokenize the first line, identify command and delegate
                  parsing
              </li>
          </ul>
          <div class="right build">
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/command.go#L19">command.go:19</a>
<pre class="prettyprint rafa lang-go">
type Command interface {
  parse(line []string) bool
  Exec()
}
</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/command.go#L19">command.go:97</a>
<pre class="prettyprint rafa lang-go">
func (s *Session) CommandLoop() {

  for line := getTokenizedLine(s.bufreader);
      line != nil; line = getTokenizedLine(s.bufreader) {
    var cmd Command = cmdSelect(line[0], s)
    if cmd.parse(line) {
      cmd.Exec()
    }
  }
}
</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/command.go#L24">command.go:24</a>
<pre class="prettyprint rafa lang-go">
type StorageCommand struct {
  session     *Session
  command     string
  key         string
  flags       uint32
  exptime     uint32
  bytes       uint32
  cas_unique  uint64
  noreply     bool
  data        []byte
}
</pre>
          </div>
      </article>

      <article class="cols2 wider taller">
      <h3>Design - Phase 2 - Storage API</h3>
      <ul class="left build">
          <li>Parsing and command building example: get/gets</li>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/command.go#L215">command.go:215</a>
<pre class="prettyprint rafa lang-go">
func (self *RetrievalCommand) parse(line []string) bool {
  if len(line) < 2 {
    return Error(self.session, ClientError, "Bad retrieval command: missing parameters")
  }
  self.command = line[0]
  self.keys = line[1:]
  return true
}
</pre>

      </ul>
      <ul class="right build">
          <li>Basic Storage implementation, just use a map[string]</li>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/mapcachestorage.go#L9">mapcachestorage.go:9</a>
<pre class="prettyprint rafa lang-go">
type MapCacheStorage struct {
	storageMap map[string]*StorageEntry
	rwLock     sync.RWMutex
}
type StorageEntry struct {
  exptime    uint32
  flags      uint32
  bytes      uint32
  cas_unique uint64
  content    []byte
}
</pre>

      </ul>
          <div style="clear: all">
          <ul class="build">
              <li>CacheStorage: core key-value storage</li>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/cachestorage.go#L22">cachestorage.go:22</a>
<pre class="prettyprint rafa lang-go">
type CacheStorage interface {

  // Store this data.
  Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (previous *StorageEntry, result *StorageEntry)

  // Store this data, but only if the server *doesn't* already hold data for this key
  Add(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (err ErrorCode, result *StorageEntry)</pre>
          </ul>
              </div>

      </article>

      <article>
          <h3>Design - Phase 3 - Sync and Partitioning</h3>
          <ul class="build">
              <li>As there'll be many goroutines accessing this map directly, we need to sync, old school.</li>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/mapcachestorage.go#L32">mapcachestorage.go:32</a>
<pre class="prettyprint rafa lang-go">
func (self *MapCacheStorage) Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (previous *StorageEntry, result *StorageEntry) {
	self.rwLock.Lock()
	defer self.rwLock.Unlock()
	entry, present := self.storageMap[key]
	var newEntry *StorageEntry
	if present && !entry.expired() {
		newEntry = &StorageEntry{exptime, flags, bytes, entry.cas_unique + 1, content}
		self.storageMap[key] = newEntry
		return entry, newEntry
	}
	newEntry = &StorageEntry{exptime, flags, bytes, 0, content}
	self.storageMap[key] = newEntry
	return nil, newEntry
}</pre>
              <li>If many clients are connected, the map sync would be a bottleneck</li>
          </ul>

      </article>
      <article class="cols2 wider">
      <h3>Design - Phase 3 - Sync and Partitioning</h3>
      <ul class="left build">
          <li>Maps can be easily partitioned, by its keys (a.k.a. sharding)</li>
          <li>HashingStorage composes a set (array) of map storages.</li>
      </ul>
      <ul class="right build">
          <li>It's inmutable, so it doesn't need to be synchronized</li>
          <li>Just chooses the appropiate bucket and delegates to that CacheStorage</li>
      </ul>
          <ul class="build">
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/hashingstorage.go#L59">hashingstorage.go:59</a>
<pre class="prettyprint rafa lang-go">
func (self *HashingStorage) findBucket(key string) CacheStorage {
	storageIndex := self.hasher(key) % self.size
	storage := self.storageBuckets[storageIndex]
	return storage
}</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/hashingstorage.go#L19">hashingstorage.go:19</a>
<pre class="prettyprint rafa lang-go">
func (self *HashingStorage) Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (previous *StorageEntry, result *StorageEntry) {
	return self.findBucket(key).Set(key, flags, exptime, bytes, content)
}

func (self *HashingStorage) Add(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (err ErrorCode, result *StorageEntry) {
	return self.findBucket(key).Add(key, flags, exptime, bytes, content)
}</pre>

          </ul>

      </article>
      <article>
          <h3>Design - Phase 4 - Expiration</h3>
          <ul class="build">
              <li>Memcached supports expiration control</li>
              <li>Expiration is something that will happen in the future, but
                  won't get any notifications
              </li>
              <li>Brute force solution, periodically visit every key/value and
                  check if expired
              </li>
              <li>Lazy solution, expire entries only when new commands are to be
                  applied to the same key
              </li>
              <li>Decent solutions, keep track of entries that will expire</li>

              <ul>
                  <li>Fast lookup of entries to expire</li>
                  <li>Low maintenance of bookkeeping data structure</li>
              </ul>
          </ul>
      </article>
      <article class="cols2 wider">
          <h3>Expiration: Generational entries</h3>
          <ul class="left build">
              <ul>
                  <li>keep entries grouped by same expiry time slot</li>
                  <li>when a key is updated, possibly update the group</li>
                  <li>when a group time slot is over, expire it completely</li>
              </ul>
              <li>Bookkeeping is constant in time</li>
              <li>Generations can grow in time for non uniform expiring times</li>
          </ul>
          <ul class="right build">
      <a target="_blank" class="ref"
         href="https://github.com/rdarder/gocached/blob/master/generationalstorage.go#L50">generationalstorage.go:50</a>
<pre class="prettyprint rafa lang-go">
type GenerationalStorage struct {
  generations     map[int64] *Generation
  updatesChannel  chan UpdateMessage
  cacheStorage    CacheStorage
  lastCollected   int64
  items           uint64
}</pre>
      <a target="_blank" class="ref"
         href="https://github.com/rdarder/gocached/blob/master/generationalstorage.go#L33">generationalstorage.go:33</a>
<pre class="prettyprint rafa lang-go">
type Generation struct {
  startEpoch    int64
  inhabitants   map[string] bool
}
</pre>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/generationalstorage.go#L65">generationalstorage.go:65</a>
<pre class="prettyprint rafa lang-go">
func (self *GenerationalStorage) removeGenerationToCollect(now int64) *Generation {
  if now >= self.lastCollected + GenerationSize {
    gen := self.generations[now]
    self.generations[now] = nil, false
    self.lastCollected += GenerationSize
    return gen
  }
  return nil
}
</pre>
              </ul>

      </article>
      <article class="cols2 wider">
          <h3>Expiration: Time sorted bookkeeping</h3>
          <ul class="left build">
              <li>Use a heap to maintain entries in order. Add() is O(log(n)) in time</li>
              <li>Periodically get the tip of the heap entries, possibly expiring map entries</li>
              <li>An update would be costly, as we loose reference from the key to the heap position</li>
              <li>Allow spurious heap entries (i.e, when exptime is changed). Memory leak</li>

          </ul>
          <ul class="right build">
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/expiry/heap.go#L8">heap.go:8</a>
<pre class="prettyprint rafa lang-go">
type Entry struct {
	Key     *string
	Exptime uint32
}
type Heap []Entry
</pre>
              <a target="_blank" class="ref"
                 href="https://github.com/rdarder/gocached/blob/master/heapexpiringstorage.go#L10">heapexpiringstorage.go:10</a>
<pre class="prettyprint rafa lang-go">
type HeapExpiringStorage struct {
  CacheStorage
  updatesChannel  chan UpdateMessage
	heap *expiry.Heap
}

func (hs *HeapExpiringStorage) ProcessUpdates() {
  for {
    msg := <-hs.updatesChannel
    switch msg.op {
    case Add, Change:
      hs.AddEntry(expiry.Entry{&msg.key, uint32(msg.newEpoch)}, uint32(msg.currentEpoch))
    case Collect:
      logger.Println("Collecting expired entries")
      hs.Collect(uint32(msg.currentEpoch))
    }
  }
}
</pre>

      </article>

    <article>
        <h3>Design - Phase 5 - Plumbing</h3>
        <ul class="build">
            <li>How do we implement different expiration/bookkeeping
                strategies?
            </li>
            <li>Solution1: make each bookkeeping strategy implement the storage
                interface
            </li><ul>
            <li>Can compose a mapstorage and delegate most storage logic</li>

        </ul>
            <li>What if we want to compose a HashingStorage?</li>
            <ul>
                <li>HashingStorage(bookkeeping(mapstorage)) vs
                    bookkeeping(HashingStorage(mapstorage))
                </li>
                <li>Wrapper soup</li>
            </ul>
        </ul>
    </article>
    <article>
        <h3>Design - Phase 5 - Plumbing</h3>
        <ul class="build">
                <li>Solution 2: Let's have event notifications from the storage</li>
                <li>just a decorator on a CacheStorage</li>
                <a target="_blank" class="ref"
                   href="https://github.com/rdarder/gocached/blob/master/eventnotifierstorage.go#L3">eventnotifierstorage.go:3</a>
<pre class="prettyprint rafa lang-go">
type EventNotifierStorage struct {
  updatesChannel chan UpdateMessage
  storage CacheStorage
}
</pre>
                <li>the notifying storage just propagates the event and delegates functionality</li>
                <li>bookkeeping structure can read the notifications</li>
                <li>bookkeeping will expire entries on the target storage when appropiate</li>
        </ul>
    </article>

    <article>
        <h3>Event notification</h3>
        <a target="_blank" class="ref"
           href="https://github.com/rdarder/gocached/blob/master/eventnotifierstorage.go#L33">eventnotifierstorage.go:33</a>
<pre class="prettyprint rafa lang-go">
func (self *EventNotifierStorage) Set(key string, flags uint32, exptime uint32, bytes uint32, content []byte) (*StorageEntry, *StorageEntry) {
  previous, updated := self.storage.Set(key, flags, exptime, bytes, content)
  if (previous != nil) {
    self.updatesChannel <- UpdateMessage{Change, key, int64(previous.exptime), int64(exptime)}
  } else {
    self.updatesChannel <- UpdateMessage{Add, key, 0, int64(exptime)}
  }
  return previous, updated
}</pre>

    </article>

        <article>
          <h3>Building The Storage</h3>
          <a target="_blank" class="ref"
             href="https://github.com/rdarder/gocached/blob/master/gocached.go#L33">gocached.go:33</a>
<pre class="prettyprint rafa lang-go">
if *partitions > 1 {
    partition_storage = newHashingStorage(uint32(*partitions), base_storage_factory)
} else {
    partition_storage = base_storage_factory()
}

// eventful storage implementation selection
switch *storage_choice {
case "leak":
    logger.Print("warning, will not expire entries")
    eventful_storage = partition_storage
case "generational":
    updatesChannel := make(chan UpdateMessage, 5000)
    eventful_storage = newEventNotifierStorage(partition_storage, updatesChannel)
    newGenerationalStorage(*expiring_frequency, partition_storage, updatesChannel)
case "heap":
    updatesChannel := make(chan UpdateMessage, 5000)
    eventful_storage = newEventNotifierStorage(partition_storage, updatesChannel)
    NewHeapExpiringStorage(*expiring_frequency, partition_storage, updatesChannel)
}</pre>
      </article>

    <article>
        <h3>Conclusions</h3>
        <ul class="build">
            <li>Less than 1k SLOC</li>
            <li>Mostly memcached compliant</li>
            <li>Informal benchmarks: gocached runs 30% slower than memcached</li>
            <li>Easy to read and modify</li>
        </ul>
    </article>
    </section>

  </body>
</html>
